//
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#ifndef THIRD_PARTY_CEL_CPP_EVAL_COMPILER_COMPREHENSION_VULNERABILITY_CHECK_H_
#define THIRD_PARTY_CEL_CPP_EVAL_COMPILER_COMPREHENSION_VULNERABILITY_CHECK_H_

#include "base/ast_internal/expr.h"

namespace google::api::expr::runtime {

// Test the given comprehension node for exponential memory consumption
// vulnerability.
//
// Hand-rolled ASTs or custom Macro implementations can reference the implicit
// accumulator variable in comprehensions to generate objects exponential in the
// size of the inputs. Type checked expressions using the built-in macros and
// functions are not susceptible to this.
//
// This check is not exhaustive, but will catch most accidental triggers of
// this behavior in the standard env. It does not consider custom extension
// functions.
//
// This implementation recursively traverses the AST, so it is not safe for
// deeply nested ASTs or in environments with smaller stack limits.
//
// conceptual example with a generalized reducer macro:
// [1, 2, 3, 4]
//   .reduce(
//     /*iter_var=*/ unused,
//     /*accu_var=*/ accu,
//     /*accu_init=*/ [1],
//     /*loop_step=*/ accu + accu,
//     /*result=*/ accu)
// resulting list sizes per iteration: 2, 4, 8, 16.
bool ComprehensionHasMemoryExhaustionVulnerability(
    const cel::ast_internal::Comprehension& comprehension);

}  // namespace google::api::expr::runtime

#endif  // THIRD_PARTY_CEL_CPP_EVAL_COMPILER_COMPREHENSION_VULNERABILITY_CHECK_H_
